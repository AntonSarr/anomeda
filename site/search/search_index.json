{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Anomeda anomeda package helps you analyze non-aggregated time-series data with Python . Here is a brief example of how it can work. \"Why has the number of our website visits decreased a week ago? What kind of users caused that?\" - anomeda will answer such questions quickly by processing non-aggregated visits of your website. Specifically, it will show you, for instance, that users from the X country using the Y device suddenly stopped visiting your website. Not only that, even if you are not aware of any significant change of the number of visits, anomeda will highlight the cluster of events where it happened. Is it fraudulent activity, a paused marketing campaign or technical issues? It's up to you to investigate! The package is easy-to-use and adjustable enough to meet a wide range of real scenarios. Find project in its GitHub repo . The Documentation is also available. Basic usage Let's say your data contains two sets of columns. Firstly, values you want to track in an aggregated or non-aggregated way, like \"visit a website\", \"purchase\" events or rows with aggregated \"number of errors per minute\". In anomeda, we call it a metric . Secondly, corresponding characteristics, like \"country\", \"device name\", \"goods category\" or similar (we call it measures ). If you know that the metric changed its values and you need to know the reason, with anomeda you can run a few lines of code: import anomeda normal_period = anomeda.DataFrame( data1, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_continuous_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_continuous_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) abnormal_period = anomeda.DataFrame( data2, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) anomeda.explain_values_difference( normal_period, abnormal_period, measures_to_iterate='combinations' ) Output will look like a pandas.DataFrame object containig average values , trends of the metric in every single cluster, the description of how they differ and how the differences contribute to the overall metric. It will let you easily find the culprits of anomalies and take actions rapidly. As you might have noticed, anomeda is capable of processing continous measures , which means you still can them as measures! It is possible because of automatical discretization mechanism embedded in the package. However, you may pass your own discrete values of continous features. Visit the Documentation page of the project to know more. Use cases anomeda also lets do the following: - Detect metric's anomalies and find the clusters of rows, sharing common features, which caused that - Find clusters of rows sharing common features which make the metric increase or decrease (clusters where metric's values have a positive or a negative trend) See the Usage page of the documentation for the details. Installing The GitHub repo contains the source distribution and built distribution files in dist folder. You must have pandas , numpy , sklearn , scipy installed. Contribution You are very welcome to contribute to the project! Contacts If you have any questions related to anomeda project, feel free reaching out to the author: Anton Saroka, Data Scientist anton.soroka.1313@gmail.com","title":"Overview"},{"location":"#introduction-to-anomeda","text":"anomeda package helps you analyze non-aggregated time-series data with Python . Here is a brief example of how it can work. \"Why has the number of our website visits decreased a week ago? What kind of users caused that?\" - anomeda will answer such questions quickly by processing non-aggregated visits of your website. Specifically, it will show you, for instance, that users from the X country using the Y device suddenly stopped visiting your website. Not only that, even if you are not aware of any significant change of the number of visits, anomeda will highlight the cluster of events where it happened. Is it fraudulent activity, a paused marketing campaign or technical issues? It's up to you to investigate! The package is easy-to-use and adjustable enough to meet a wide range of real scenarios. Find project in its GitHub repo . The Documentation is also available.","title":"Introduction to Anomeda"},{"location":"#basic-usage","text":"Let's say your data contains two sets of columns. Firstly, values you want to track in an aggregated or non-aggregated way, like \"visit a website\", \"purchase\" events or rows with aggregated \"number of errors per minute\". In anomeda, we call it a metric . Secondly, corresponding characteristics, like \"country\", \"device name\", \"goods category\" or similar (we call it measures ). If you know that the metric changed its values and you need to know the reason, with anomeda you can run a few lines of code: import anomeda normal_period = anomeda.DataFrame( data1, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_continuous_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_continuous_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) abnormal_period = anomeda.DataFrame( data2, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) anomeda.explain_values_difference( normal_period, abnormal_period, measures_to_iterate='combinations' ) Output will look like a pandas.DataFrame object containig average values , trends of the metric in every single cluster, the description of how they differ and how the differences contribute to the overall metric. It will let you easily find the culprits of anomalies and take actions rapidly. As you might have noticed, anomeda is capable of processing continous measures , which means you still can them as measures! It is possible because of automatical discretization mechanism embedded in the package. However, you may pass your own discrete values of continous features. Visit the Documentation page of the project to know more.","title":"Basic usage"},{"location":"#use-cases","text":"anomeda also lets do the following: - Detect metric's anomalies and find the clusters of rows, sharing common features, which caused that - Find clusters of rows sharing common features which make the metric increase or decrease (clusters where metric's values have a positive or a negative trend) See the Usage page of the documentation for the details.","title":"Use cases"},{"location":"#installing","text":"The GitHub repo contains the source distribution and built distribution files in dist folder. You must have pandas , numpy , sklearn , scipy installed.","title":"Installing"},{"location":"#contribution","text":"You are very welcome to contribute to the project!","title":"Contribution"},{"location":"#contacts","text":"If you have any questions related to anomeda project, feel free reaching out to the author: Anton Saroka, Data Scientist anton.soroka.1313@gmail.com","title":"Contacts"},{"location":"api_reference/","text":"API reference Here you can find the documentation for all available endpoints of anomeda Python package. DataFrame DataFrame ( * args , ** kwargs ) Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 List containing columns considered as measures in the data. measures_types ( dict ) \u2013 Dict containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } discretized_measures ( 'dict' = None ) \u2013 Dict containig name of the measure as key and array-like object containing discretized values of the measure of the same shape as original data. If measure is in 'continuous' list of measures_types parameter, it will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 Columns to be considered as an index (usually a date or a timestamp). Must be present among columns if provided. If None, index name from the pandas.DataFrame is taken. metric_name ( 'str' = None ) \u2013 Column with a metric to be analyzed agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' ) copy_anomeda_df () Return a copy of an anomeda.DataFrame object get_agg_func () Return the function used to aggregate the metric by measures. get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } } get_discretized_measures () Return discretized versions of continous measures. get_index_name () Return the name of an index column. get_measures_names () Return a list of columns considered as measures. get_measures_types () Return the measures_types dict. get_metric_name () Return the name of a metric column. replace_df ( data : pandas . DataFrame , inplace = False , keep_clusters : bool = False , keep_trends : bool = False , keep_discretization : bool = False ) Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame set_agg_func ( agg_func ) Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby set_discretization_mapping ( discretized_measures_mapping , recalculate_measures = True ) Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } }) set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had. set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] }) set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first compare_clusters ( data : anomeda . DataFrame , period1 : str , period2 : str , clusters : list = None ) Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters ) extract_trends ( x : numpy . ndarray [ int ], y : numpy . ndarray [ float ], max_trends : int | 'auto' = 'auto' , min_var_reduction : float [ 0 , 1 ] | None = 0.5 , verbose : bool = False ) Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) } find_anomalies ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), clusters : list = None , anomalies_conf : dict = { 'p_large' : 1 , 'p_low' : 1 , 'n_neighbors' : 3 }, return_all_points : bool = False , trend_fitting_conf : dict = None ) Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data ) fit_trends ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), trend_fitting_conf : dict = { 'max_trends' : 'auto' , 'min_var_reduction' : 0.75 }, save_trends : bool = True , breakdown : 'no' | 'all-clusters' | list [ str ] = 'no' , min_cluster_size : int | None = None , max_cluster_size : int | None = None , plot : bool = False , df : bool = True , verbose : bool = False ) Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True ) plot_trends ( data : 'anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends()' , clusters : list = None , colors : dict = None , show_points = True ) Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"API Reference"},{"location":"api_reference/#api-reference","text":"Here you can find the documentation for all available endpoints of anomeda Python package.","title":"API reference"},{"location":"api_reference/#DataFrame","text":"","title":"DataFrame"},{"location":"api_reference/#DataFrame.DataFrame","text":"Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 List containing columns considered as measures in the data. measures_types ( dict ) \u2013 Dict containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } discretized_measures ( 'dict' = None ) \u2013 Dict containig name of the measure as key and array-like object containing discretized values of the measure of the same shape as original data. If measure is in 'continuous' list of measures_types parameter, it will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 Columns to be considered as an index (usually a date or a timestamp). Must be present among columns if provided. If None, index name from the pandas.DataFrame is taken. metric_name ( 'str' = None ) \u2013 Column with a metric to be analyzed agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' )","title":"DataFrame"},{"location":"api_reference/#DataFrame.DataFrame.copy_anomeda_df","text":"Return a copy of an anomeda.DataFrame object","title":"copy_anomeda_df()"},{"location":"api_reference/#DataFrame.DataFrame.get_agg_func","text":"Return the function used to aggregate the metric by measures.","title":"get_agg_func()"},{"location":"api_reference/#DataFrame.DataFrame.get_discretization_mapping","text":"Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } }","title":"get_discretization_mapping()"},{"location":"api_reference/#DataFrame.DataFrame.get_discretized_measures","text":"Return discretized versions of continous measures.","title":"get_discretized_measures()"},{"location":"api_reference/#DataFrame.DataFrame.get_index_name","text":"Return the name of an index column.","title":"get_index_name()"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_names","text":"Return a list of columns considered as measures.","title":"get_measures_names()"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_types","text":"Return the measures_types dict.","title":"get_measures_types()"},{"location":"api_reference/#DataFrame.DataFrame.get_metric_name","text":"Return the name of a metric column.","title":"get_metric_name()"},{"location":"api_reference/#DataFrame.DataFrame.replace_df","text":"Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame","title":"replace_df()"},{"location":"api_reference/#DataFrame.DataFrame.set_agg_func","text":"Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby","title":"set_agg_func()"},{"location":"api_reference/#DataFrame.DataFrame.set_discretization_mapping","text":"Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } })","title":"set_discretization_mapping()"},{"location":"api_reference/#DataFrame.DataFrame.set_discretized_measures","text":"Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had.","title":"set_discretized_measures()"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_names","text":"Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures","title":"set_measures_names()"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_types","text":"Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] })","title":"set_measures_types()"},{"location":"api_reference/#DataFrame.DataFrame.set_metric_name","text":"Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first","title":"set_metric_name()"},{"location":"api_reference/#utils.compare_clusters","text":"Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters )","title":"compare_clusters()"},{"location":"api_reference/#utils.extract_trends","text":"Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) }","title":"extract_trends()"},{"location":"api_reference/#utils.find_anomalies","text":"Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data )","title":"find_anomalies()"},{"location":"api_reference/#utils.fit_trends","text":"Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True )","title":"fit_trends()"},{"location":"api_reference/#utils.plot_trends","text":"Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"plot_trends()"},{"location":"user_guide/","text":"User Guide After the library is installed, you can pass the pandas.DataFrame object with events to anomeda and look for insights about the metric's behavior. Create an anomeda.DataFrame object The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method. Discretization of numeric measures When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method Find an anomaly change of the metric anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. They both currently use a method based of fitting a generic trend line and analyzing differences from a trend. There are some parameters for the method which represent which part of anomalies from both tailes to present: p_large = 1 # 100% of anomalies with high values will be returned p_low = 1 # 100% of anomalies with low values will be returned The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs. Find the root cause of an anomaly change of the metric When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change. Find clusters of events which make your metric rise or decrease Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Usage"},{"location":"user_guide/#user-guide","text":"After the library is installed, you can pass the pandas.DataFrame object with events to anomeda and look for insights about the metric's behavior.","title":"User Guide"},{"location":"user_guide/#create-an-anomedadataframe-object","text":"The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method.","title":"Create an anomeda.DataFrame object"},{"location":"user_guide/#discretization-of-numeric-measures","text":"When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method","title":"Discretization of numeric measures"},{"location":"user_guide/#find-an-anomaly-change-of-the-metric","text":"anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. They both currently use a method based of fitting a generic trend line and analyzing differences from a trend. There are some parameters for the method which represent which part of anomalies from both tailes to present: p_large = 1 # 100% of anomalies with high values will be returned p_low = 1 # 100% of anomalies with low values will be returned The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs.","title":"Find an anomaly change of the metric"},{"location":"user_guide/#find-the-root-cause-of-an-anomaly-change-of-the-metric","text":"When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change.","title":"Find the root cause of an anomaly change of the metric"},{"location":"user_guide/#find-clusters-of-events-which-make-your-metric-rise-or-decrease","text":"Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Find clusters of events which make your metric rise or decrease"}]}