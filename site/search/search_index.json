{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Anomeda anomeda package helps you analyze non-aggregated time-series data with Python . Here is a brief example of how anomeda can work for you. \"Why has the number of our website visits decreased a week ago? What kind of users caused that?\" - anomeda will answer such questions quickly by processing non-aggregated visits of your website. It will show you, for instance, that users from the X country using the Y device suddenly stopped visiting your website. Not only that, even if you are not aware of any significant change of the number of visits, anomeda will highlight the cluster of events where it happened. Is it fraudulent activity, a paused marketing campaign or technical issues? It's up to you to investigate. The package is easy-to-use and adjustable enough to meet a wide range of real scenarios. The basic object, anomeda.DataFrame , inherits pandas.DataFrame , so you will find the API familiar. In addition, there are different options for fine-tuning alghorithms used under the hood. Some of what anomeda can do for your non-aggregated data : Highlight time points and clusters when the trend, mean or variance changed Fit trends for any cluster considering the points where trends change Highlight time points and clusters if the anomalies were observed, considering trend at that moment Compare time periods and find clusters changing the metric Find the project in its GitHub repo . Explore the Documentation of anomeda . Quick start Let's imagine you oversee the number of visits of a website. You have a table with visits. Typically you just aggregate them by a datetime column and monitor from 3 to 5 dashboards with overall number of visits, as well as visits of important pages, visits from specific systems, visits of specific users clustes, etc. Here is what you would do with anomeda . Let's define an anomeda object. import anomeda anomeda_df = anomeda.DataFrame( df, # pandas.DataFrame measures_names=['country', 'system', 'url', 'duration'], # columns represending measures or characteristics of your events measures_types={ 'categorical': [;'country', 'system', 'url'], 'continuous': ['duration'] # measures can also be continuous - anomeda will take care of clustering them properly }, index_name='date', metric_name='visit', # dummy metric, always 1 agg_func='sum' # function that is used to aggregate metric ) anomeda.DataFrame inherits pandas.DataFrame , so you can treat them similarly. NOTE Some pandas methods are not yet adapted for anomeda . They return a new pandas.DataFrame instead of a anomeda.DataFrame . You just need to initialize an anomeda object with a returned object in that case. Let's try to extract trends for important clusters from the data. trends = anomeda.fit_trends( anomeda_df, trend_fitting_conf={'max_trends': 'auto', 'min_var_reduction': 0.75}, # set the number of trends automatically, # try to reduce error variance compared to error of estimating values by 1-line trend by 75% breakdown='all-clusters', # fit trends for clusters extracted from all possible sets of measures min_cluster_size=3 # skip small clusters ) Typically you will see something like this: You can then plot the trends using the plot_trends method. You can choose a specific cluster or plot them all together. anomeda.plot_trends(anomeda_df, clusters=['`country`==\"Germany\"']) The output will look like this: Of course, you may have no idea which cluster caused the problem and what to plot. Almost always you know only that there is a decrease of an overall metric and you need to find the culprits. Let's utilize another method -- anomeda.compare_clusters . anomeda.compare_clusters( anomeda_df, period1='date < 30', period2='date >= 30' ) You see the clusters you fitted before and comparison between their characteristics. The result is quite hefty, but you can easily add your own metrics and sort clusters so that the cluster you are looking for will be on top. For example, look at how different means in the second cluster are. The second cluster corresponds to Germany (the first cluster consists of all events, so we are not interested in it now). Finally, you can check if there are any point anomalies present in any of your clusters. anomeda.find_anomalies( anomeda_df, anomalies_conf: {'p_large': 1, 'p_low': 1, 'n_neighbors': 3} ) The output will look like this: If you plot the metric with its clusters, it would look quite reasonable. There are some nuances of how to use anomeda wisely and powerfully. For example, you may use same anomeda methods simply with numpy arrays, without creating DataFrame's! See full Documentation for more details and hints. Installing The GitHub repo contains the source and built distribution files in dist folder. You must have such packages be installed: pandas numpy sklearn scipy matplotlib Contribution You are very welcome to contribute to the project. The contribution guide is coming soon. Contacts If you have any questions related to anomeda project, feel free reaching out to the author.","title":"Overview"},{"location":"#introduction-to-anomeda","text":"anomeda package helps you analyze non-aggregated time-series data with Python . Here is a brief example of how anomeda can work for you. \"Why has the number of our website visits decreased a week ago? What kind of users caused that?\" - anomeda will answer such questions quickly by processing non-aggregated visits of your website. It will show you, for instance, that users from the X country using the Y device suddenly stopped visiting your website. Not only that, even if you are not aware of any significant change of the number of visits, anomeda will highlight the cluster of events where it happened. Is it fraudulent activity, a paused marketing campaign or technical issues? It's up to you to investigate. The package is easy-to-use and adjustable enough to meet a wide range of real scenarios. The basic object, anomeda.DataFrame , inherits pandas.DataFrame , so you will find the API familiar. In addition, there are different options for fine-tuning alghorithms used under the hood. Some of what anomeda can do for your non-aggregated data : Highlight time points and clusters when the trend, mean or variance changed Fit trends for any cluster considering the points where trends change Highlight time points and clusters if the anomalies were observed, considering trend at that moment Compare time periods and find clusters changing the metric Find the project in its GitHub repo . Explore the Documentation of anomeda .","title":"Introduction to Anomeda"},{"location":"#quick-start","text":"Let's imagine you oversee the number of visits of a website. You have a table with visits. Typically you just aggregate them by a datetime column and monitor from 3 to 5 dashboards with overall number of visits, as well as visits of important pages, visits from specific systems, visits of specific users clustes, etc. Here is what you would do with anomeda . Let's define an anomeda object. import anomeda anomeda_df = anomeda.DataFrame( df, # pandas.DataFrame measures_names=['country', 'system', 'url', 'duration'], # columns represending measures or characteristics of your events measures_types={ 'categorical': [;'country', 'system', 'url'], 'continuous': ['duration'] # measures can also be continuous - anomeda will take care of clustering them properly }, index_name='date', metric_name='visit', # dummy metric, always 1 agg_func='sum' # function that is used to aggregate metric ) anomeda.DataFrame inherits pandas.DataFrame , so you can treat them similarly. NOTE Some pandas methods are not yet adapted for anomeda . They return a new pandas.DataFrame instead of a anomeda.DataFrame . You just need to initialize an anomeda object with a returned object in that case. Let's try to extract trends for important clusters from the data. trends = anomeda.fit_trends( anomeda_df, trend_fitting_conf={'max_trends': 'auto', 'min_var_reduction': 0.75}, # set the number of trends automatically, # try to reduce error variance compared to error of estimating values by 1-line trend by 75% breakdown='all-clusters', # fit trends for clusters extracted from all possible sets of measures min_cluster_size=3 # skip small clusters ) Typically you will see something like this: You can then plot the trends using the plot_trends method. You can choose a specific cluster or plot them all together. anomeda.plot_trends(anomeda_df, clusters=['`country`==\"Germany\"']) The output will look like this: Of course, you may have no idea which cluster caused the problem and what to plot. Almost always you know only that there is a decrease of an overall metric and you need to find the culprits. Let's utilize another method -- anomeda.compare_clusters . anomeda.compare_clusters( anomeda_df, period1='date < 30', period2='date >= 30' ) You see the clusters you fitted before and comparison between their characteristics. The result is quite hefty, but you can easily add your own metrics and sort clusters so that the cluster you are looking for will be on top. For example, look at how different means in the second cluster are. The second cluster corresponds to Germany (the first cluster consists of all events, so we are not interested in it now). Finally, you can check if there are any point anomalies present in any of your clusters. anomeda.find_anomalies( anomeda_df, anomalies_conf: {'p_large': 1, 'p_low': 1, 'n_neighbors': 3} ) The output will look like this: If you plot the metric with its clusters, it would look quite reasonable. There are some nuances of how to use anomeda wisely and powerfully. For example, you may use same anomeda methods simply with numpy arrays, without creating DataFrame's! See full Documentation for more details and hints.","title":"Quick start"},{"location":"#installing","text":"The GitHub repo contains the source and built distribution files in dist folder. You must have such packages be installed: pandas numpy sklearn scipy matplotlib","title":"Installing"},{"location":"#contribution","text":"You are very welcome to contribute to the project. The contribution guide is coming soon.","title":"Contribution"},{"location":"#contacts","text":"If you have any questions related to anomeda project, feel free reaching out to the author.","title":"Contacts"},{"location":"anomeda_api/","text":"Anomeda API Here you can find the documentation for available endpoints of anomeda Python package. compare_clusters compare_clusters ( data : anomeda . DataFrame , period1 : str , period2 : str , clusters : list = None , ) Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters ) extract_trends extract_trends ( x : numpy . ndarray [ int ], y : numpy . ndarray [ float ], max_trends : int | \"auto\" = \"auto\" , min_var_reduction : float [ 0 , 1 ] | None = 0.5 , verbose : bool = False , ) Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) } find_anomalies find_anomalies ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), clusters : list = None , anomalies_conf : dict = { \"p_large\" : 1 , \"p_low\" : 1 , \"n_neighbors\" : 3 , }, return_all_points : bool = False , trend_fitting_conf : dict = None , ) Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data ) fit_trends fit_trends ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), trend_fitting_conf : dict = { \"max_trends\" : \"auto\" , \"min_var_reduction\" : 0.75 , }, save_trends : bool = True , breakdown : \"no\" | \"all-clusters\" | list [ str ] = \"no\" , min_cluster_size : int | None = None , max_cluster_size : int | None = None , plot : bool = False , df : bool = True , verbose : bool = False , ) Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True ) plot_trends plot_trends ( data : \"anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends()\" , clusters : list = None , colors : dict = None , show_points = True , ) Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"Anomeda methods"},{"location":"anomeda_api/#anomeda-api","text":"Here you can find the documentation for available endpoints of anomeda Python package.","title":"Anomeda API"},{"location":"anomeda_api/#utils.compare_clusters","text":"compare_clusters ( data : anomeda . DataFrame , period1 : str , period2 : str , clusters : list = None , ) Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters )","title":"compare_clusters"},{"location":"anomeda_api/#utils.extract_trends","text":"extract_trends ( x : numpy . ndarray [ int ], y : numpy . ndarray [ float ], max_trends : int | \"auto\" = \"auto\" , min_var_reduction : float [ 0 , 1 ] | None = 0.5 , verbose : bool = False , ) Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) }","title":"extract_trends"},{"location":"anomeda_api/#utils.find_anomalies","text":"find_anomalies ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), clusters : list = None , anomalies_conf : dict = { \"p_large\" : 1 , \"p_low\" : 1 , \"n_neighbors\" : 3 , }, return_all_points : bool = False , trend_fitting_conf : dict = None , ) Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data )","title":"find_anomalies"},{"location":"anomeda_api/#utils.fit_trends","text":"fit_trends ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), trend_fitting_conf : dict = { \"max_trends\" : \"auto\" , \"min_var_reduction\" : 0.75 , }, save_trends : bool = True , breakdown : \"no\" | \"all-clusters\" | list [ str ] = \"no\" , min_cluster_size : int | None = None , max_cluster_size : int | None = None , plot : bool = False , df : bool = True , verbose : bool = False , ) Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True )","title":"fit_trends"},{"location":"anomeda_api/#utils.plot_trends","text":"plot_trends ( data : \"anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends()\" , clusters : list = None , colors : dict = None , show_points = True , ) Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"plot_trends"},{"location":"api_reference/","text":"Anomeda API Here you can find the documentation for all available endpoints of anomeda Python package. DataFrame DataFrame ( * args , ** kwargs ) Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' ) copy_anomeda_df copy_anomeda_df () Return a copy of an anomeda.DataFrame object get_agg_func get_agg_func () Return the function used to aggregate the metric by measures. get_discretization_mapping get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } } get_discretized_measures get_discretized_measures () Return discretized versions of continous measures. get_index_name get_index_name () Return the name of an index column. get_measures_names get_measures_names () Return a list of columns considered as measures. get_measures_types get_measures_types () Return the measures_types dict. get_metric_name get_metric_name () Return the name of a metric column. replace_df replace_df ( data : pandas . DataFrame , inplace = False , keep_clusters : bool = False , keep_trends : bool = False , keep_discretization : bool = False , ) Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame set_agg_func set_agg_func ( agg_func ) Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby set_discretization_mapping set_discretization_mapping ( discretized_measures_mapping , recalculate_measures = True ) Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } }) set_discretized_measures set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had. set_measures_names set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures set_measures_types set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] }) set_metric_name set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first compare_clusters compare_clusters ( data : anomeda . DataFrame , period1 : str , period2 : str , clusters : list = None , ) Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters ) extract_trends extract_trends ( x : numpy . ndarray [ int ], y : numpy . ndarray [ float ], max_trends : int | \"auto\" = \"auto\" , min_var_reduction : float [ 0 , 1 ] | None = 0.5 , verbose : bool = False , ) Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) } find_anomalies find_anomalies ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), clusters : list = None , anomalies_conf : dict = { \"p_large\" : 1 , \"p_low\" : 1 , \"n_neighbors\" : 3 , }, return_all_points : bool = False , trend_fitting_conf : dict = None , ) Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data ) fit_trends fit_trends ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), trend_fitting_conf : dict = { \"max_trends\" : \"auto\" , \"min_var_reduction\" : 0.75 , }, save_trends : bool = True , breakdown : \"no\" | \"all-clusters\" | list [ str ] = \"no\" , min_cluster_size : int | None = None , max_cluster_size : int | None = None , plot : bool = False , df : bool = True , verbose : bool = False , ) Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True ) plot_trends plot_trends ( data : \"anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends()\" , clusters : list = None , colors : dict = None , show_points = True , ) Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"Anomeda API"},{"location":"api_reference/#anomeda-api","text":"Here you can find the documentation for all available endpoints of anomeda Python package.","title":"Anomeda API"},{"location":"api_reference/#DataFrame.DataFrame","text":"DataFrame ( * args , ** kwargs ) Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' )","title":"DataFrame"},{"location":"api_reference/#DataFrame.DataFrame.copy_anomeda_df","text":"copy_anomeda_df () Return a copy of an anomeda.DataFrame object","title":"copy_anomeda_df"},{"location":"api_reference/#DataFrame.DataFrame.get_agg_func","text":"get_agg_func () Return the function used to aggregate the metric by measures.","title":"get_agg_func"},{"location":"api_reference/#DataFrame.DataFrame.get_discretization_mapping","text":"get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } }","title":"get_discretization_mapping"},{"location":"api_reference/#DataFrame.DataFrame.get_discretized_measures","text":"get_discretized_measures () Return discretized versions of continous measures.","title":"get_discretized_measures"},{"location":"api_reference/#DataFrame.DataFrame.get_index_name","text":"get_index_name () Return the name of an index column.","title":"get_index_name"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_names","text":"get_measures_names () Return a list of columns considered as measures.","title":"get_measures_names"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_types","text":"get_measures_types () Return the measures_types dict.","title":"get_measures_types"},{"location":"api_reference/#DataFrame.DataFrame.get_metric_name","text":"get_metric_name () Return the name of a metric column.","title":"get_metric_name"},{"location":"api_reference/#DataFrame.DataFrame.replace_df","text":"replace_df ( data : pandas . DataFrame , inplace = False , keep_clusters : bool = False , keep_trends : bool = False , keep_discretization : bool = False , ) Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame","title":"replace_df"},{"location":"api_reference/#DataFrame.DataFrame.set_agg_func","text":"set_agg_func ( agg_func ) Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby","title":"set_agg_func"},{"location":"api_reference/#DataFrame.DataFrame.set_discretization_mapping","text":"set_discretization_mapping ( discretized_measures_mapping , recalculate_measures = True ) Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } })","title":"set_discretization_mapping"},{"location":"api_reference/#DataFrame.DataFrame.set_discretized_measures","text":"set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had.","title":"set_discretized_measures"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_names","text":"set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures","title":"set_measures_names"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_types","text":"set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] })","title":"set_measures_types"},{"location":"api_reference/#DataFrame.DataFrame.set_metric_name","text":"set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first","title":"set_metric_name"},{"location":"api_reference/#utils.compare_clusters","text":"compare_clusters ( data : anomeda . DataFrame , period1 : str , period2 : str , clusters : list = None , ) Compare metric values for 2 periods. The method generates pandas.DataFrame object with descriptions for two periods, for each cluster. You can use it to identify the cluster or set of clusters caused the differences in the overall metric values between two periods. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed period1 ( str ) \u2013 Query to filter the first period. For example, 'dt < 10'. period2 ( str ) \u2013 Query to filter the second period. For example, 'dt >= 10'. clusters ( list , default: None ) \u2013 List of clusters to use in the comparison. The objects in the list are queries used in pandas.DataFrame.query. If None, all clusters are used. Default is None. Returns: output ( DataFrame ) \u2013 Object describing the clusters and the changes in the metric behavior between them. Examples: anomeda.compare_clusters( data, period1='dt < 10', period2='dt >= 10', clusters=None # means all clusters )","title":"compare_clusters"},{"location":"api_reference/#utils.extract_trends","text":"extract_trends ( x : numpy . ndarray [ int ], y : numpy . ndarray [ float ], max_trends : int | \"auto\" = \"auto\" , min_var_reduction : float [ 0 , 1 ] | None = 0.5 , verbose : bool = False , ) Fit and return automatocally fitted linear trends for given X and Y. The method can extract more than 1 trend if the metric significantly changed its behavior. The sensibility of the method to identify trend changes are set by parameters \"max_trends\" and \"min_var_reduction\". Parameters: x ( ndarray [ int ] ) \u2013 Indeces corresponding to time points. Must be an increasing array of integers. Some of the values may be omitted, e.g such x is OK: [0, 1, 5, 10]. y ( ndarray [ float ] ) \u2013 Metric values corresponding to time points. max_trends ( int | auto , default: \"auto\" ) \u2013 Number of trends to extract. If int, the method extracts defined amount of trends or less. Less trends may be extracted if no more trends were found or if the min_var_reduction is reached. It would mean taht the variance is already explained by that amount of trends. If 'auto', the method defines the number of trends automatically using min_var_reduction parameter. Default is 'auto'. min_var_reduction ( float [0, 1] | None , default: 0.5 ) \u2013 % of the variance of approximation error that must be reduced by adding trends comparing to the variance of the initial approximation with one trend. Values closer to 1 will cause extracting more trends, since more trends reduce the variance better. Values closer to 0 will cause producing less trends. If max_trends is set and reached, the extraction finishes regardless the value of the variance. If None, then not used. Default is 0.5. verbose ( bool , default: False ) \u2013 If to produce more logs. Default False. Returns: trends ( dict ) \u2013 Dict contains the extracted trends in the format { trend_id: (xmin_inc, xmax_exc, (trend_slope, trend_intersept), (n_samples, metric_mean, mae, metric_sum)), ... } Examples: >>> x = np . array ([ 0 , 1 , 4 , 5 ]) >>> y = np . array ([ 11.2 , 10.4 , 3.4 , 3.1 ]) >>> anomeda . extract_trends ( x , y , max_trends = 2 ) { 0: (0, 4, (-0.7999999999999989, 11.2), (2, 10.8, 0.0, 21.6)), # trend 1, for date points from 0 (inc) to 4 (excl) # with slope -0.79 and intercept 11.2 # consisting of 2 samples, # metric mean over date points is 10.8, # mae for fitting trend over date points is 0.0 # sum for all metric values is 21.6 1: (4, 6, (-0.2999999999999998, 4.6), (2, 3.25, 0.0, 6.5)) }","title":"extract_trends"},{"location":"api_reference/#utils.find_anomalies","text":"find_anomalies ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), clusters : list = None , anomalies_conf : dict = { \"p_large\" : 1 , \"p_low\" : 1 , \"n_neighbors\" : 3 , }, return_all_points : bool = False , trend_fitting_conf : dict = None , ) Find metric anomalies by looking for the most extreme metric changes. The method finds differences between real metric and a fitted trends, find points with extreme differences and marks them as anomalies. You can find anomalies for automatically extracted clusters only if passing an anomeda.DataFrame. Parameters: data ( DataFrame | ( ndarray [ int ], ndarray [ float ]) ) \u2013 Object containing metric values to be analyzed. Trends must be fitted for the object with anomeda.fit_trends() method if anomeda.DataFrame is passed. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. anomalies_conf ( dict , default: {'p_large': 1., 'p_low': 1., 'n_neighbors': 3} ) \u2013 Dict containing 'p_large' and 'p_low' values. Both are float values between 0 and 1 corresponding to the % of the anomalies with largest and lowest metric values to be returned. For example, if you set 'p_low' to 0, no points with abnormally low metric values will be returned; if 0.5, then 50% of points with abnormally values will be returned, etc. If some of the keys is not present or None, 1 is assumed. 'n_neighbors' means number of neighbors parameter for sklearn.neighbors.LocalOutlierFactor class. The class is used to find points with abnormally large MAE. The more the parameter, typically, the less sensitive the model to anomalies. return_all_points ( bool , default: False ) \u2013 If False, only anomaly points are returned. If True, all points with anomalies marks are returned. Default False. trend_fitting_conf ( dict , default: None ) \u2013 Used only if data is not anomeda.DataFrame, but numpy arrays, to run anomeda.fit_trends method for them. Parameters are similar to those you would pass to the argument anomeda.fit_trends(..., trend_fitting_conf=...). Returns: res ( DataFrame ) \u2013 A DataFrame containing fields 'cluster', 'index', 'metric_value', 'fitted_trend_value', 'anomaly'. Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . find_anomalies ( data )","title":"find_anomalies"},{"location":"api_reference/#utils.fit_trends","text":"fit_trends ( data : anomeda . DataFrame | ( numpy . ndarray [ int ], numpy . ndarray [ float ]), trend_fitting_conf : dict = { \"max_trends\" : \"auto\" , \"min_var_reduction\" : 0.75 , }, save_trends : bool = True , breakdown : \"no\" | \"all-clusters\" | list [ str ] = \"no\" , min_cluster_size : int | None = None , max_cluster_size : int | None = None , plot : bool = False , df : bool = True , verbose : bool = False , ) Fit trends for a time series. Fit trends using the data from an anomeda.DataFrame or an numpy.ndarray with metric values. You can fit trends for automatically extracted clusters only if passing an anomeda.DataFrame. If anomeda.DataFrame is passed and \"save_trends\" is True, it stores the trends into anomeda.DataFrame._trends attribute of the class every time the method is called. The method returns a pandas.DataFrame describing trends and/or plots the trends. Parameters: data ( DataFrame | ( ndarray , ndarray ) ) \u2013 Object containing metric values. If numpy.ndarray, a tuple of arrays corresponding to x (data points) and y (metric values) respectively. trend_fitting_conf ( dict , default: {'max_trends': 'auto', 'min_var_reduction': 0.75} ) \u2013 Parameters for calling anomeda.extract_trends() function. It consists of 'max_trends' parameter, which is responsible for the maximum number of trends that you want to identify, and 'min_var_reduction' parameter, which describes what part of variance must be reduced by estimating trends. Values close to 1 will produce more trends since more trends reduce variance more signigicantly. Default is {'max_trends': 'auto', 'min_var_reduction': 0.75}. save_trends ( bool , default: True ) \u2013 If False, return pandas.DataFrame with trends description without assigning it to the anomeda.DataFrame._trends. breakdown ( no | all - clusters | list [ str ] , default: 'no' ) \u2013 If 'no', the metric is grouped by date points only. If 'all-clusters', then all combinations of measures are used to create clusters for fitting trends within them. If list[str], then only combinations of measures specified in the list are used. min_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is less than the value. max_cluster_size ( int , default: None ) \u2013 Skip clusters whose total size among all date points is more than the value. plot ( bool , default: False ) \u2013 Indicator if to plot fitted trends. anomeda.plot_trends is responsibe for plotting if the flag is True. df ( bool , default: True ) \u2013 Indicator if to return a pandas.DataFrame containing fitted trends. verbose ( bool , default: False ) \u2013 Indicator if to print additional output. Returns: resp ( DataFrame ) \u2013 An object containing information about trends Examples: >>> fitted_trends = anomeda . fit_trends ( data , trend_fitting_conf = { 'max_trends' : 3 }, min_cluster_size = 3 , plot = True , df = True )","title":"fit_trends"},{"location":"api_reference/#utils.plot_trends","text":"plot_trends ( data : \"anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends()\" , clusters : list = None , colors : dict = None , show_points = True , ) Plot fitted trends. Plot trends either from anomeda.DataFrame instance or using a response from anomeda.fit_trends(). Parameters: data ( anomeda.DataFrame | pandas.DataFrame returned from anomeda.fit_trends() ) \u2013 Object containing trends to be plotted. clusters ( list , default: None ) \u2013 List of clusters to plot. The objects in the list are queries used in pandas.DataFrame.query. colors ( dict , default: None ) \u2013 Dictionary with a mapping between clusters and colors used in matplotlib. show_points ( bool , default: True ) \u2013 Indicator if to show data points on plots. Returns: None \u2013 Examples: >>> anomeda . fit_trends ( data ) >>> anomeda . plot_trends ( data )","title":"plot_trends"},{"location":"dataframe_api/","text":"Anomeda DataFrame Here you can find the documentation for anomeda.DataFrame class. DataFrame DataFrame ( * args , ** kwargs ) Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' ) copy_anomeda_df copy_anomeda_df () Return a copy of an anomeda.DataFrame object get_agg_func get_agg_func () Return the function used to aggregate the metric by measures. get_discretization_mapping get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } } get_discretized_measures get_discretized_measures () Return discretized versions of continous measures. get_index_name get_index_name () Return the name of an index column. get_measures_names get_measures_names () Return a list of columns considered as measures. get_measures_types get_measures_types () Return the measures_types dict. get_metric_name get_metric_name () Return the name of a metric column. replace_df replace_df ( data : pandas . DataFrame , inplace = False , keep_clusters : bool = False , keep_trends : bool = False , keep_discretization : bool = False , ) Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame set_agg_func set_agg_func ( agg_func ) Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby set_discretization_mapping set_discretization_mapping ( discretized_measures_mapping , recalculate_measures = True ) Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } }) set_discretized_measures set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had. set_measures_names set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures set_measures_types set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] }) set_metric_name set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first","title":"Anomeda DataFrame"},{"location":"dataframe_api/#anomeda-dataframe","text":"Here you can find the documentation for anomeda.DataFrame class.","title":"Anomeda DataFrame"},{"location":"dataframe_api/#DataFrame.DataFrame","text":"DataFrame ( * args , ** kwargs ) Bases: DataFrame Data to be processed by anomeda. The class inherits pandas.DataFrame. Please note that whenever the underlying pandas.DataFrame object is changed, you may need to apply the constructor again in order to keep some of the characteristics of the data consistent with the new object. Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. Examples: anmd_df = anomeda.DataFrame( df, measures_names=['dummy_measure_col', 'dummy_numeric_measure_col'], measures_types={ 'categorical': ['dummy_measure_col'], 'continuous': ['dummy_numeric_measure_col'] }, index_name='dt', metric_name='metric_col', agg_func='sum' )","title":"DataFrame"},{"location":"dataframe_api/#DataFrame.DataFrame.copy_anomeda_df","text":"copy_anomeda_df () Return a copy of an anomeda.DataFrame object","title":"copy_anomeda_df"},{"location":"dataframe_api/#DataFrame.DataFrame.get_agg_func","text":"get_agg_func () Return the function used to aggregate the metric by measures.","title":"get_agg_func"},{"location":"dataframe_api/#DataFrame.DataFrame.get_discretization_mapping","text":"get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], # [[inc, exl)] 1: [[0.9855150328648835, 2.458970726947438]] # [[inc, exl)] } }","title":"get_discretization_mapping"},{"location":"dataframe_api/#DataFrame.DataFrame.get_discretized_measures","text":"get_discretized_measures () Return discretized versions of continous measures.","title":"get_discretized_measures"},{"location":"dataframe_api/#DataFrame.DataFrame.get_index_name","text":"get_index_name () Return the name of an index column.","title":"get_index_name"},{"location":"dataframe_api/#DataFrame.DataFrame.get_measures_names","text":"get_measures_names () Return a list of columns considered as measures.","title":"get_measures_names"},{"location":"dataframe_api/#DataFrame.DataFrame.get_measures_types","text":"get_measures_types () Return the measures_types dict.","title":"get_measures_types"},{"location":"dataframe_api/#DataFrame.DataFrame.get_metric_name","text":"get_metric_name () Return the name of a metric column.","title":"get_metric_name"},{"location":"dataframe_api/#DataFrame.DataFrame.replace_df","text":"replace_df ( data : pandas . DataFrame , inplace = False , keep_clusters : bool = False , keep_trends : bool = False , keep_discretization : bool = False , ) Replace the pandas.DataFrame content, underlying the anomeda.DataFrame, with a new one Parameters: data ( DataFrame ) \u2013 A new data object. inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame","title":"replace_df"},{"location":"dataframe_api/#DataFrame.DataFrame.set_agg_func","text":"set_agg_func ( agg_func ) Set a function to aggregate the metric by measures. Parameters: agg_func \u2013 Can be \"sum\", \"avg\", \"count\" or callable compatible with pandas.DataFrame.groupby","title":"set_agg_func"},{"location":"dataframe_api/#DataFrame.DataFrame.set_discretization_mapping","text":"set_discretization_mapping ( discretized_measures_mapping , recalculate_measures = True ) Set custom thresholds for discretization. Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Threshold must have the following format. As you can see, several different ranges of continuous values may be mapped into the same descrete values if you want. The lower bound must be including, the higher bound must be excluding. { 'measure_name': { discrete_value: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [..., ...], ...], ... }, ... } Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.00, 0.05001], [0.95, 1.001]], # may correspond to \"extreme\" values; 0.05 are 1. are excluding bounds 1: [[0.5, 0.94999]] # may correspond to \"normal\" values; 94999 is an excluding bound } })","title":"set_discretization_mapping"},{"location":"dataframe_api/#DataFrame.DataFrame.set_discretized_measures","text":"set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had.","title":"set_discretized_measures"},{"location":"dataframe_api/#DataFrame.DataFrame.set_measures_names","text":"set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures","title":"set_measures_names"},{"location":"dataframe_api/#DataFrame.DataFrame.set_measures_types","text":"set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] })","title":"set_measures_types"},{"location":"dataframe_api/#DataFrame.DataFrame.set_metric_name","text":"set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first","title":"set_metric_name"},{"location":"usage_guide/","text":"Usage Guide What is anomeda.DataFrame anomeda.DataFrame is class used to store the time-series data and its metadata. It inherits pandas.DataFrame . One of the implications of that fact is that anomeda.DataFrame.__init__ processes the same parameters as its ancestor and a few more . Specifically: Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. As you may have noticed, most of the parameters are optional. If you don't specify a parameter, a default value will be used. Or you will be notified once you use anomeda.fit_trends , anomeda.find_anomalies or other methods that you need to specify something additionally. Here is some examples of how you can initialize a new anomeda.DataFrame : # With just a pandas.DataFrame and metric name anomeda.DataFrame(pandas_df, metric_name='my_metric') # With some measures anomeda.DataFrame(pandas_df, measures_names=['A', 'B', 'C'], metric_name='my_metric') # In a pandas.DataFrame style anomeda.DataFrame( { 'A': [0, 1, 2], 'B': [3, 4, 5], 'C': [6, 7, 8], 'my_metric': [10, 20, 30] } measures_names=['A', 'B', 'C'], metric_name='my_metric' ) # With a discretization mappging anomeda.DataFrame( pandas_df, measures_names=['A', 'B', 'C'], metric_name='my_metric', discretized_measures_mapping={ 'A': { 0: [[20, 80]], # map values from 20 to 80 to 0 - \"normal values\" 1: [[0, 20], [80, 100]], # map values from 0 and 20 or between 80 and 100 to 1 - \"abnormal values\" } } ) # And many more... NOTE 1 Some pandas methods are not yet adapted for anomeda . They return a new pandas.DataFrame instead of a anomeda.DataFrame . You just need to initialize an anomeda object with a returned object in that case. NOTE 2 The scale of undex increments is extracted automatically. It can be 1 ( Integer , if your index are integers) or a part of a timestamp ( second , minute , hour , etc). For example, if your index consists of two values ['2024-01-01 00:00:00', '2024-01-01 00:01:00'], the step is hour . However, the step may become minute once you add only one value - ['2024-01-01 00:00:00', '2024-01-01 00:01:00', '2024-01-01 00:01: 01 '], since minute is the smallest increment now. By default, anomeda does not fill the missing index values. So if there are infrequent index values, anomeda will use only them to use fit trends. TODO in new versions: add filling options A list of methods available to manipulate anomeda.DataFrame , such as getters , setters , copying , modifying the object , etc. Please follow anomeda.DataFrame API Reference for the details. Her is the full list: copy_anomeda_df get_agg_func get_discretization_mapping get_discretized_measures get_index_name get_measures_names get_measures_types get_metric_name replace_df set_agg_func set_discretization_mapping set_discretized_measures set_measures_names set_measures_types set_metric_name How we handle continuous measures Text How we fit trends Text How we detect anomalies Text Create an anomeda.DataFrame object The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method. Discretization of numeric measures When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method Find an anomaly change of the metric anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. They both currently use a method based of fitting a generic trend line and analyzing differences from a trend. There are some parameters for the method which represent which part of anomalies from both tailes to present: p_large = 1 # 100% of anomalies with high values will be returned p_low = 1 # 100% of anomalies with low values will be returned The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs. Find the root cause of an anomaly change of the metric When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change. Find clusters of events which make your metric rise or decrease Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Usage Guide"},{"location":"usage_guide/#usage-guide","text":"","title":"Usage Guide"},{"location":"usage_guide/#what-is-anomedadataframe","text":"anomeda.DataFrame is class used to store the time-series data and its metadata. It inherits pandas.DataFrame . One of the implications of that fact is that anomeda.DataFrame.__init__ processes the same parameters as its ancestor and a few more . Specifically: Parameters: *args \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. **kwargs \u2013 Parameters for initialization a pandas.DataFrame object. Other parameters must be passed as **kwargs only. measures_names ( 'list | tuple' = None ) \u2013 A list containing columns considered as measures. If None, your data is supposed to have no measures. measures_types ( 'dict' = None ) \u2013 A dictionary containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. If your data has any measures, you must provide its' types. discretized_measures_mapping ( 'dict' = None ) \u2013 Custom dictionary with a mapping between a discrete value of the meauser and corresponding continous ranges. The lower bound must be including, the higher bound must be excluding. It uses the following format: { 'measure_name': { discrete_value_1: [[continuous_threshold_min_inc, continuous_threshold_max_excl], [...]], descrete_value_2: ... } } discretized_measures ( 'dict' = None ) \u2013 A dictionary containig names of the measures as keys and array-like objects containing customly discretized values of the measure. If not provided, continuous measures will be discretized automatically. index_name ( 'str | list | None' = None ) \u2013 An index column (usually a date or a timestamp). If None, index is taken from the pandas.DataFrame. metric_name ( str ) \u2013 A metric column. agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg', 'count' or callable compatible with pandas.DataFrame.groupby. As you may have noticed, most of the parameters are optional. If you don't specify a parameter, a default value will be used. Or you will be notified once you use anomeda.fit_trends , anomeda.find_anomalies or other methods that you need to specify something additionally. Here is some examples of how you can initialize a new anomeda.DataFrame : # With just a pandas.DataFrame and metric name anomeda.DataFrame(pandas_df, metric_name='my_metric') # With some measures anomeda.DataFrame(pandas_df, measures_names=['A', 'B', 'C'], metric_name='my_metric') # In a pandas.DataFrame style anomeda.DataFrame( { 'A': [0, 1, 2], 'B': [3, 4, 5], 'C': [6, 7, 8], 'my_metric': [10, 20, 30] } measures_names=['A', 'B', 'C'], metric_name='my_metric' ) # With a discretization mappging anomeda.DataFrame( pandas_df, measures_names=['A', 'B', 'C'], metric_name='my_metric', discretized_measures_mapping={ 'A': { 0: [[20, 80]], # map values from 20 to 80 to 0 - \"normal values\" 1: [[0, 20], [80, 100]], # map values from 0 and 20 or between 80 and 100 to 1 - \"abnormal values\" } } ) # And many more... NOTE 1 Some pandas methods are not yet adapted for anomeda . They return a new pandas.DataFrame instead of a anomeda.DataFrame . You just need to initialize an anomeda object with a returned object in that case. NOTE 2 The scale of undex increments is extracted automatically. It can be 1 ( Integer , if your index are integers) or a part of a timestamp ( second , minute , hour , etc). For example, if your index consists of two values ['2024-01-01 00:00:00', '2024-01-01 00:01:00'], the step is hour . However, the step may become minute once you add only one value - ['2024-01-01 00:00:00', '2024-01-01 00:01:00', '2024-01-01 00:01: 01 '], since minute is the smallest increment now. By default, anomeda does not fill the missing index values. So if there are infrequent index values, anomeda will use only them to use fit trends. TODO in new versions: add filling options A list of methods available to manipulate anomeda.DataFrame , such as getters , setters , copying , modifying the object , etc. Please follow anomeda.DataFrame API Reference for the details. Her is the full list:","title":"What is anomeda.DataFrame"},{"location":"usage_guide/#DataFrame.DataFrame.copy_anomeda_df","text":"","title":"copy_anomeda_df"},{"location":"usage_guide/#DataFrame.DataFrame.get_agg_func","text":"","title":"get_agg_func"},{"location":"usage_guide/#DataFrame.DataFrame.get_discretization_mapping","text":"","title":"get_discretization_mapping"},{"location":"usage_guide/#DataFrame.DataFrame.get_discretized_measures","text":"","title":"get_discretized_measures"},{"location":"usage_guide/#DataFrame.DataFrame.get_index_name","text":"","title":"get_index_name"},{"location":"usage_guide/#DataFrame.DataFrame.get_measures_names","text":"","title":"get_measures_names"},{"location":"usage_guide/#DataFrame.DataFrame.get_measures_types","text":"","title":"get_measures_types"},{"location":"usage_guide/#DataFrame.DataFrame.get_metric_name","text":"","title":"get_metric_name"},{"location":"usage_guide/#DataFrame.DataFrame.replace_df","text":"","title":"replace_df"},{"location":"usage_guide/#DataFrame.DataFrame.set_agg_func","text":"","title":"set_agg_func"},{"location":"usage_guide/#DataFrame.DataFrame.set_discretization_mapping","text":"","title":"set_discretization_mapping"},{"location":"usage_guide/#DataFrame.DataFrame.set_discretized_measures","text":"","title":"set_discretized_measures"},{"location":"usage_guide/#DataFrame.DataFrame.set_measures_names","text":"","title":"set_measures_names"},{"location":"usage_guide/#DataFrame.DataFrame.set_measures_types","text":"","title":"set_measures_types"},{"location":"usage_guide/#DataFrame.DataFrame.set_metric_name","text":"","title":"set_metric_name"},{"location":"usage_guide/#how-we-handle-continuous-measures","text":"Text","title":"How we handle continuous measures"},{"location":"usage_guide/#how-we-fit-trends","text":"Text","title":"How we fit trends"},{"location":"usage_guide/#how-we-detect-anomalies","text":"Text","title":"How we detect anomalies"},{"location":"usage_guide/#create-an-anomedadataframe-object","text":"The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method.","title":"Create an anomeda.DataFrame object"},{"location":"usage_guide/#discretization-of-numeric-measures","text":"When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method","title":"Discretization of numeric measures"},{"location":"usage_guide/#find-an-anomaly-change-of-the-metric","text":"anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. They both currently use a method based of fitting a generic trend line and analyzing differences from a trend. There are some parameters for the method which represent which part of anomalies from both tailes to present: p_large = 1 # 100% of anomalies with high values will be returned p_low = 1 # 100% of anomalies with low values will be returned The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs.","title":"Find an anomaly change of the metric"},{"location":"usage_guide/#find-the-root-cause-of-an-anomaly-change-of-the-metric","text":"When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change.","title":"Find the root cause of an anomaly change of the metric"},{"location":"usage_guide/#find-clusters-of-events-which-make-your-metric-rise-or-decrease","text":"Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Find clusters of events which make your metric rise or decrease"}]}