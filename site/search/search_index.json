{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Anomeda \"Why has the number of visits of our website decreased this week? Who are the users who caused that?\" - anomeda will help to answer such questions quickly and easily using Python with pandas package installed. You are welcome to visit GitHub repo of the project! anomeda is a Python package developed for Data Analysts, Data Scientists, BI Analysts and others. It helps to identify important metric changes and quickly find clusters in data which changed the trend of the metric or caused the anomaly. You just need to pass a pandas.DataFrame object to anomeda to start analyzing it. Let's say your data contains values you want to track in an aggregated or non-aggregated way, like \"visit a website\" or \"purchase\" events or rows with aggregated \"number of errors per minute\" (in anomeda, we call it a metric ) and corresponding characteristics, like \"country\", \"device name\", \"goods category\" (we call it measures ). If you already know that the metric changed its values and you need to know the reason, with anomeda you can run a few lines of code: import anomeda normal_period = anomeda.DataFrame( data1, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_continuous_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_continuous_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) abnormal_period = anomeda.DataFrame( data2, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) anomeda.explain_values_difference( normal_period, abnormal_period ) This code will iterate over the values of the measures and return a pandas.DataFrame explaining which values of measures caused the abnormal values of your metric and what contribution precisely they made. As you might have noticed, anomeda is capable of processing continous measures , which means you still can them as measures! It is possible because of automatical discretization mechanism embedded in the package. However, you may pass your own discrete values of continous features. anomeda also lets do the following: - Detect metric's anomalies - Find clusters which make the metric increase or decrease (clusters where metric's values have a positive or a negative trend) See the Usage page of the documentation for the details. Installing The GitHub repo contains the source distribution and built distribution files in dist folder. You must have pandas , numpy , sklearn , scipy installed. Contribution You are very welcome to contribute to the project! Contacts If you have any questions related to anomeda project, feel free reaching out to the author: Anton Saroka, Data Scientist anton.soroka.1313@gmail.com","title":"Overview"},{"location":"#introduction-to-anomeda","text":"\"Why has the number of visits of our website decreased this week? Who are the users who caused that?\" - anomeda will help to answer such questions quickly and easily using Python with pandas package installed. You are welcome to visit GitHub repo of the project! anomeda is a Python package developed for Data Analysts, Data Scientists, BI Analysts and others. It helps to identify important metric changes and quickly find clusters in data which changed the trend of the metric or caused the anomaly. You just need to pass a pandas.DataFrame object to anomeda to start analyzing it. Let's say your data contains values you want to track in an aggregated or non-aggregated way, like \"visit a website\" or \"purchase\" events or rows with aggregated \"number of errors per minute\" (in anomeda, we call it a metric ) and corresponding characteristics, like \"country\", \"device name\", \"goods category\" (we call it measures ). If you already know that the metric changed its values and you need to know the reason, with anomeda you can run a few lines of code: import anomeda normal_period = anomeda.DataFrame( data1, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_continuous_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_continuous_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) abnormal_period = anomeda.DataFrame( data2, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='date', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) anomeda.explain_values_difference( normal_period, abnormal_period ) This code will iterate over the values of the measures and return a pandas.DataFrame explaining which values of measures caused the abnormal values of your metric and what contribution precisely they made. As you might have noticed, anomeda is capable of processing continous measures , which means you still can them as measures! It is possible because of automatical discretization mechanism embedded in the package. However, you may pass your own discrete values of continous features. anomeda also lets do the following: - Detect metric's anomalies - Find clusters which make the metric increase or decrease (clusters where metric's values have a positive or a negative trend) See the Usage page of the documentation for the details.","title":"Introduction to Anomeda"},{"location":"#installing","text":"The GitHub repo contains the source distribution and built distribution files in dist folder. You must have pandas , numpy , sklearn , scipy installed.","title":"Installing"},{"location":"#contribution","text":"You are very welcome to contribute to the project!","title":"Contribution"},{"location":"#contacts","text":"If you have any questions related to anomeda project, feel free reaching out to the author: Anton Saroka, Data Scientist anton.soroka.1313@gmail.com","title":"Contacts"},{"location":"api_reference/","text":"API reference Here you can find the documentation for all available endpoints of anomeda Python package. DataFrame DataFrame ( data : pd . DataFrame , measures_names = None , measures_types = None , discretized_measures = None , index_name = None , metric_name = None , agg_func = 'sum' ) Data to be processed by anomeda package. Parameters: data ( DataFrame ) \u2013 Underlying data must be pandas.DataFrame object. measures_names ( list or tuple , default: None ) \u2013 List containing columns considered as measures in the data. measures_types ( dict , default: None ) \u2013 Dict containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. discretized_measures ( dict , default: None ) \u2013 Dict containig name of the measure as key and array-like object containing discretized values of the measure of the same shape as original data. If measure is in 'continuous' list of measures_types parameter, it will be discretized automatically. index_name ( str or list , default: None ) \u2013 Columns to be considered as an index (usually a date or a timestamp) metric_name ( str , default: None ) \u2013 Column with a metric to be analyzed agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg' or callable compatible with pandas.DataFrame.groupby Examples: anmd_df = anomeda.DataFrame( data, measures_names=['class', 'dummy_measure', 'dummy_numeric_measure'], measures_types={ 'categorical': ['class', 'dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' ) aspandas () Return a copy of a pandas.DataFrame object underlying the anomeda.DataFrame copy () Return a copy of an anomeda.DataFrame object get_agg_func () Return the function used to aggregate the metric by measures. get_discretization_mapping () Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], 1: [[0.9855150328648835, 2.458970726947438]] } } get_discretized_measures () Return discretized versions of continous measures. get_index_name () Return the name of an index column. get_measures_names () Return a list of columns considered as measures. get_measures_types () Return the measures_types dict. get_metric_name () Return the name of a metric column. mod_data ( data : pd . DataFrame , inplace = False ) Replace the pandas.DataFrame object underlying the anomeda.DataFrame with a new one Parameters: data ( DataFrame ) \u2013 A new data object inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame set_agg_func ( agg_func : str ) Set a function to aggregate the metric by measures. Parameters: agg_func ( ( str , callable ) ) \u2013 Can be either 'sum', 'avg' or callable compatible with pandas.DataFrame.groupby set_discretization_mapping ( discretized_measures_mapping ) Set custom thresholds for discretization. Threshold must have the following format { 'measure_name': { discrete_value: [[threshold1, threshold2], [threshold3, threshold4], ...], ... }, ... } Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.01, 0.98]], 1: [[0.99, 2.45]] } }) set_discretized_measures ( discretized_measures : dict ) Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had. set_index_name ( index_name ) Set a name of an index column. Parameters: index_name ( str or list ) \u2013 Column name or list of columns names containing index values. Must be present in an underling pandas.DataFrame object. If index is currenly present in measures list, you need to change the measures list first set_measures_names ( measures_names ) Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures set_measures_types ( measures_types : dict ) Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] }) set_metric_name ( metric_name ) Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first describe_trend ( data ) Fit and return parameters of a linear trend for the given metric. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: a ( float ) \u2013 Coefficient a of a line f(x) = a + b * x fitted to the metric, where x is time values and f(x) is metric values b ( float ) \u2013 Coefficient b of a line f(x) = a + b * x fitted to the metric, where x is time values and f(x) is metric values describe_trends_by_clusters ( data ) Fit and return parameters of a linear trend of each cluster for given metric. Output object type is a pandas.DataFrame object. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the trends. describe_variance_by_clusters ( data ) Return variances of metric in each cluster in given data. Output object type is a pandas.DataFrame object. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the variances. explain_values_difference ( data1 , data2 , measures_to_iterate = 'shared' ) Find clusters in data which caused the most significant changes of an average value of the metric. data1 and data2 must have a common metric and at least 1 common measure. Parameters: data1 ( DataFrame ) \u2013 Object containing data to be analyzed data2 ( DataFrame ) \u2013 Object containing data to be analyzed measures_to_iterate \u2013 Measures combinations used to create clusters to look for differences between metric values. If 'shared', then one set consisting of all measures shared between data objects is used. If 'combinations', then all possible combinations of measures are used. If list, then lists inside are used to create sets. Examples: anomeda.explain_values_difference( data1, data2, measures_to_iterate=[['dummy_measure'], ['dummy_measure', 'dummy_numeric_measure']] // equivalent to measures_to_iterate='combinations' if data1 and data2 have only 'dummy_measure' and 'dummy_numeric_measure' in common ) Returns: output ( DataFrame ) \u2013 Object describing the clusters with the most significant changes of average value of a metric. explain_variance_difference ( data1 , data2 ) Find clusters in data which caused the most significant changes of variance of a metric when comparing data1 and data2. Output object type is a pandas.DataFrame object. Parameters: data1 ( DataFrame ) \u2013 Object containing data to be analyzed data2 ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the clusters with the most significant changes of variance of a metric. find_anomalies ( data , n = 1 , p = ( 0.02 , 0.98 ), normal_whole_window = True , read_deltas_consequently = False ) Find metric anomalies by looking for the most extreme metric changes. The method decides if a metric value is an anomaly by looking at the n metric changes before and comparing them to \"normal\" changes we observed from historical or all available data. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed n ( int , default: 1 ) \u2013 The number of index values the model looks back when gathering metric changes for a particular point to decide if it is an anomaly. Larger values will make the model mark a few point after the first anomaly as anomalies as well. p ( tuple of float , default: (0.02, 0.98) ) \u2013 Tuple of lowest and highest percentiles of day-to-day metric changes. Deltas within this range will be considered as \"normal\" normal_whole_window ( bool , default: True ) \u2013 Bool indicating if all the metric deltas in period [dt - n days, dt] period have to in \"normal\" range (True) or at least one them (False) in order metric value to be considered as a normal point read_deltas_consequently ( bool , default: False ) \u2013 Bool indicating if to scan metric deltas consequently (day by day, only historical data) (True) or to scan all available metric changes at once (False) Returns: index ( array ) \u2013 Array of unique indexes anomalies ( numpy.array of bool ) \u2013 Bool array indicating if a metric was abnormal at a particar index point find_anomalies_by_clusters ( data , n = 1 , p = ( 0.02 , 0.98 ), normal_whole_window = True , read_deltas_consequently = False ) Find metric anomalies in each cluster by looking for the most extreme metric changes. The method decides if a metric value is an anomaly by looking at the n metric changes before and comparing them to \"normal\" changes we observed from historical or all available data. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed n ( int , default: 1 ) \u2013 The number of index values the model looks back when gathering metric changes for a particular point to decide if it is an anomaly. Larger values will make the model mark a few point after the first anomaly as anomalies as well. p ( tuple of float , default: (0.02, 0.98) ) \u2013 Tuple of lowest and highest percentiles of day-to-day metric changes. Deltas within this range will be considered as \"normal\" normal_whole_window ( bool , default: True ) \u2013 Bool indicating if all the metric deltas in period [dt - n days, dt] period have to in \"normal\" range (True) or at least one them (False) in order metric value to be considered as a normal point read_deltas_consequently ( bool , default: False ) \u2013 Bool indicating if to scan metric deltas consequently (day by day, only historical data) (True) or to scan all available metric changes at once (False) Returns: clusters_anomalies ( list of dict ) \u2013 List containing cluster and its anomalies. The keys in the cluster-dict are \"cluster\", \"indeces\", \"anomalies\"","title":"API Reference"},{"location":"api_reference/#api-reference","text":"Here you can find the documentation for all available endpoints of anomeda Python package.","title":"API reference"},{"location":"api_reference/#DataFrame","text":"","title":"DataFrame"},{"location":"api_reference/#DataFrame.DataFrame","text":"Data to be processed by anomeda package. Parameters: data ( DataFrame ) \u2013 Underlying data must be pandas.DataFrame object. measures_names ( list or tuple , default: None ) \u2013 List containing columns considered as measures in the data. measures_types ( dict , default: None ) \u2013 Dict containing 'categorical' and/or 'continuous' keys and list of measures as values. Continuous measures will be discretized automatically if not presented in discretized_measures parameter. discretized_measures ( dict , default: None ) \u2013 Dict containig name of the measure as key and array-like object containing discretized values of the measure of the same shape as original data. If measure is in 'continuous' list of measures_types parameter, it will be discretized automatically. index_name ( str or list , default: None ) \u2013 Columns to be considered as an index (usually a date or a timestamp) metric_name ( str , default: None ) \u2013 Column with a metric to be analyzed agg_func \u2013 Way of aggregating metric_name by measures. Can be 'sum', 'avg' or callable compatible with pandas.DataFrame.groupby Examples: anmd_df = anomeda.DataFrame( data, measures_names=['class', 'dummy_measure', 'dummy_numeric_measure'], measures_types={ 'categorical': ['class', 'dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' )","title":"DataFrame"},{"location":"api_reference/#DataFrame.DataFrame.aspandas","text":"Return a copy of a pandas.DataFrame object underlying the anomeda.DataFrame","title":"aspandas"},{"location":"api_reference/#DataFrame.DataFrame.copy","text":"Return a copy of an anomeda.DataFrame object","title":"copy"},{"location":"api_reference/#DataFrame.DataFrame.get_agg_func","text":"Return the function used to aggregate the metric by measures.","title":"get_agg_func"},{"location":"api_reference/#DataFrame.DataFrame.get_discretization_mapping","text":"Return a dict with a mapping between discrete values and actual ranges of continous measures. In some cases, there may be more than one interval for each discrete values Examples: >>> anmd_df.get_discretization_mapping() { 'dummy_numeric_measure': { 0: [[0.08506988648110014, 0.982366623262143]], 1: [[0.9855150328648835, 2.458970726947438]] } }","title":"get_discretization_mapping"},{"location":"api_reference/#DataFrame.DataFrame.get_discretized_measures","text":"Return discretized versions of continous measures.","title":"get_discretized_measures"},{"location":"api_reference/#DataFrame.DataFrame.get_index_name","text":"Return the name of an index column.","title":"get_index_name"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_names","text":"Return a list of columns considered as measures.","title":"get_measures_names"},{"location":"api_reference/#DataFrame.DataFrame.get_measures_types","text":"Return the measures_types dict.","title":"get_measures_types"},{"location":"api_reference/#DataFrame.DataFrame.get_metric_name","text":"Return the name of a metric column.","title":"get_metric_name"},{"location":"api_reference/#DataFrame.DataFrame.mod_data","text":"Replace the pandas.DataFrame object underlying the anomeda.DataFrame with a new one Parameters: data ( DataFrame ) \u2013 A new data object inplace ( bool , default: False ) \u2013 If True, then no new object will be returned. Otherwise, create and return a new anomeda.DataFrame","title":"mod_data"},{"location":"api_reference/#DataFrame.DataFrame.set_agg_func","text":"Set a function to aggregate the metric by measures. Parameters: agg_func ( ( str , callable ) ) \u2013 Can be either 'sum', 'avg' or callable compatible with pandas.DataFrame.groupby","title":"set_agg_func"},{"location":"api_reference/#DataFrame.DataFrame.set_discretization_mapping","text":"Set custom thresholds for discretization. Threshold must have the following format { 'measure_name': { discrete_value: [[threshold1, threshold2], [threshold3, threshold4], ...], ... }, ... } Parameters: discretized_measures_mapping ( dict ) \u2013 Dict with mapping between discrete value of the meause and corresponding continous values. Examples: anmd_df.set_discretization_mapping({ 'dummy_numeric_measure': { 0: [[0.01, 0.98]], 1: [[0.99, 2.45]] } })","title":"set_discretization_mapping"},{"location":"api_reference/#DataFrame.DataFrame.set_discretized_measures","text":"Set custom discretization for continous measures. Parameters: discretized_measures ( dict ) \u2013 Dict containing discrete values of each measure in the format {'measure_name': [0, 1, 1, ...]}. Array of values must have same shape as original measure had.","title":"set_discretized_measures"},{"location":"api_reference/#DataFrame.DataFrame.set_index_name","text":"Set a name of an index column. Parameters: index_name ( str or list ) \u2013 Column name or list of columns names containing index values. Must be present in an underling pandas.DataFrame object. If index is currenly present in measures list, you need to change the measures list first","title":"set_index_name"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_names","text":"Let anomeda.DataFrame object know what columns are measures. Columns are picked from an underlying pandas.DataFrame object, so they must be present there. Parameters: measures_names ( list of str ) \u2013 List containing columns which will be considered as measures","title":"set_measures_names"},{"location":"api_reference/#DataFrame.DataFrame.set_measures_types","text":"Set measures types. Measure can be either 'categorical' or 'continous'. Types are used to clusterize the data properly. Parameters: measures_types ( dict ) \u2013 Dict containing 'continous' and/or 'categorical' keys and lists of measures as values Examples: anmd_df.set_measures_types({ 'continous': ['numeric_measure_1'], 'categorical': ['measure_1'] })","title":"set_measures_types"},{"location":"api_reference/#DataFrame.DataFrame.set_metric_name","text":"Set the name of a metric to be analyzed. Parameters: metric_name ( str ) \u2013 Must be present among columns of an underlying pandas.DataFrame. If metric column is currently set as a measure, you need to change the list of measures first","title":"set_metric_name"},{"location":"api_reference/#utils.describe_trend","text":"Fit and return parameters of a linear trend for the given metric. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: a ( float ) \u2013 Coefficient a of a line f(x) = a + b * x fitted to the metric, where x is time values and f(x) is metric values b ( float ) \u2013 Coefficient b of a line f(x) = a + b * x fitted to the metric, where x is time values and f(x) is metric values","title":"describe_trend"},{"location":"api_reference/#utils.describe_trends_by_clusters","text":"Fit and return parameters of a linear trend of each cluster for given metric. Output object type is a pandas.DataFrame object. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the trends.","title":"describe_trends_by_clusters"},{"location":"api_reference/#utils.describe_variance_by_clusters","text":"Return variances of metric in each cluster in given data. Output object type is a pandas.DataFrame object. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the variances.","title":"describe_variance_by_clusters"},{"location":"api_reference/#utils.explain_values_difference","text":"Find clusters in data which caused the most significant changes of an average value of the metric. data1 and data2 must have a common metric and at least 1 common measure. Parameters: data1 ( DataFrame ) \u2013 Object containing data to be analyzed data2 ( DataFrame ) \u2013 Object containing data to be analyzed measures_to_iterate \u2013 Measures combinations used to create clusters to look for differences between metric values. If 'shared', then one set consisting of all measures shared between data objects is used. If 'combinations', then all possible combinations of measures are used. If list, then lists inside are used to create sets. Examples: anomeda.explain_values_difference( data1, data2, measures_to_iterate=[['dummy_measure'], ['dummy_measure', 'dummy_numeric_measure']] // equivalent to measures_to_iterate='combinations' if data1 and data2 have only 'dummy_measure' and 'dummy_numeric_measure' in common ) Returns: output ( DataFrame ) \u2013 Object describing the clusters with the most significant changes of average value of a metric.","title":"explain_values_difference"},{"location":"api_reference/#utils.explain_variance_difference","text":"Find clusters in data which caused the most significant changes of variance of a metric when comparing data1 and data2. Output object type is a pandas.DataFrame object. Parameters: data1 ( DataFrame ) \u2013 Object containing data to be analyzed data2 ( DataFrame ) \u2013 Object containing data to be analyzed Returns: output ( DataFrame ) \u2013 Object describing the clusters with the most significant changes of variance of a metric.","title":"explain_variance_difference"},{"location":"api_reference/#utils.find_anomalies","text":"Find metric anomalies by looking for the most extreme metric changes. The method decides if a metric value is an anomaly by looking at the n metric changes before and comparing them to \"normal\" changes we observed from historical or all available data. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed n ( int , default: 1 ) \u2013 The number of index values the model looks back when gathering metric changes for a particular point to decide if it is an anomaly. Larger values will make the model mark a few point after the first anomaly as anomalies as well. p ( tuple of float , default: (0.02, 0.98) ) \u2013 Tuple of lowest and highest percentiles of day-to-day metric changes. Deltas within this range will be considered as \"normal\" normal_whole_window ( bool , default: True ) \u2013 Bool indicating if all the metric deltas in period [dt - n days, dt] period have to in \"normal\" range (True) or at least one them (False) in order metric value to be considered as a normal point read_deltas_consequently ( bool , default: False ) \u2013 Bool indicating if to scan metric deltas consequently (day by day, only historical data) (True) or to scan all available metric changes at once (False) Returns: index ( array ) \u2013 Array of unique indexes anomalies ( numpy.array of bool ) \u2013 Bool array indicating if a metric was abnormal at a particar index point","title":"find_anomalies"},{"location":"api_reference/#utils.find_anomalies_by_clusters","text":"Find metric anomalies in each cluster by looking for the most extreme metric changes. The method decides if a metric value is an anomaly by looking at the n metric changes before and comparing them to \"normal\" changes we observed from historical or all available data. Parameters: data ( DataFrame ) \u2013 Object containing data to be analyzed n ( int , default: 1 ) \u2013 The number of index values the model looks back when gathering metric changes for a particular point to decide if it is an anomaly. Larger values will make the model mark a few point after the first anomaly as anomalies as well. p ( tuple of float , default: (0.02, 0.98) ) \u2013 Tuple of lowest and highest percentiles of day-to-day metric changes. Deltas within this range will be considered as \"normal\" normal_whole_window ( bool , default: True ) \u2013 Bool indicating if all the metric deltas in period [dt - n days, dt] period have to in \"normal\" range (True) or at least one them (False) in order metric value to be considered as a normal point read_deltas_consequently ( bool , default: False ) \u2013 Bool indicating if to scan metric deltas consequently (day by day, only historical data) (True) or to scan all available metric changes at once (False) Returns: clusters_anomalies ( list of dict ) \u2013 List containing cluster and its anomalies. The keys in the cluster-dict are \"cluster\", \"indeces\", \"anomalies\"","title":"find_anomalies_by_clusters"},{"location":"user_guide/","text":"User Guide After the library is installed, you can pass the pandas.DataFrame object with events to anomeda and look for insights about the metric's behavior. Create an anomeda.DataFrame object The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method. Discretization of numeric measures When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method Find an anomaly change of the metric anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. First, there are some parameters for the method (see docsctring of the methods for details): n = 3 p = (0.05, 0.95) normal_whole_window = True read_deltas_consequently = False The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs. Find the root cause of an anomaly change of the metric When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change. Find clusters of events which make your metric rise or decrease Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Usage"},{"location":"user_guide/#user-guide","text":"After the library is installed, you can pass the pandas.DataFrame object with events to anomeda and look for insights about the metric's behavior.","title":"User Guide"},{"location":"user_guide/#create-an-anomedadataframe-object","text":"The base object anomeda is working with is the DataFrame. It is based on pandas.DataFrame object which contains events represented by rows or time series (aggregated events). It may contain: - Index - Usually a datetime of a corresponding event - Measures - Columns which describes an event, like \"country\", \"region\", \"client category\", etc. Measures can be numerical and categorical - Metric - Metric you want to track, can be either aggregated, like \"count of visits in a period\", or non-aggregated, like \"fact of visit\" anmd_df = anomeda.DataFrame( data, # pandas.DataFrame measures_names=['dummy_measure', 'dummy_numeric_measure'], # columns represending measures measures_types={ 'categorical': ['dummy_measure'], 'continuous': ['dummy_numeric_measure'] }, index_name='dt', metric_name='metric', agg_func='sum' # function that is used to aggregate metric if more than 1 metric value will be found for a particular set of measure values ) Each of the parameters can be changed with corresponding method, like anomeda.DataFrame.set_measures_names , anomeda.DataFrame.set_measures_types , anomeda.DataFrame.set_index_name , etc. The parameters can be retrieved with a corresponding getter, like anomeda.DataFrame.get_measures_names , anomeda.DataFrame.get_measures_types , anomeda.DataFrame.get_index_name , etc. The underlying pandas.DataFrame object can be changed without creating a new instance of anomeda.DataFrame with mod_data method. IF you need to get the pandas.DataFrame representation of an object, you can use aspandas method.","title":"Create an anomeda.DataFrame object"},{"location":"user_guide/#discretization-of-numeric-measures","text":"When continuous measures are passed, they will be mapped to discrete values by sklearn.mixture.BayesianGaussianMixture by default. You can pass your own discrete values of continuous measure when creating an anomeda.DataFrame object (see discretized_measures parameter of anomeda.DataFrame constructor) or later on (see method anomeda.DataFrame.set_discretized_measures ) If you need to see the discretized values, you can use anomeda.DataFrame.get_discretization_mapping method","title":"Discretization of numeric measures"},{"location":"user_guide/#find-an-anomaly-change-of-the-metric","text":"anomeda.find_anomalies and anomeda.find_anomalies_by_clusters are responsible for looking for unusual metric changes in the data. First, there are some parameters for the method (see docsctring of the methods for details): n = 3 p = (0.05, 0.95) normal_whole_window = True read_deltas_consequently = False The output is unique and sorted index values and an indication if total metric value is an anomaly or not. The values are aggregated using agg_func parameter. index_values, anomalies_flag = anomeda.find_anomalies(anmd_df, n=n, p=p, normal_whole_window=normal_whole_window, read_deltas_consequently=read_deltas_consequently) The methods use an alghorithm based on analyzing the historical changes of metric values in order to decide if the current point is an anomaly. The parameters mentioned before can tune the method for your needs.","title":"Find an anomaly change of the metric"},{"location":"user_guide/#find-the-root-cause-of-an-anomaly-change-of-the-metric","text":"When you found an unusual period (whether by using anomeda.find_anomalies or by yourself), you can compare it to other period in order to find which events caused the difference between metric values. All you need to do is to call anomeda.explain_values_difference with 2 anomeda.DataFrame objects containing data you want to compare. It will automatically detect clusters of events using measure values, compare the metric values and return the result. anomeda.explain_values_difference( anmd_df1, anmd_df2 ) The output is a pandas.DataFrame with average metric value in each cluster in both periods and the differences between them. Thus, sorting by the absolute or relative differences and average values, you can find the most important clusters in terms of its contribution to the overall metric's change.","title":"Find the root cause of an anomaly change of the metric"},{"location":"user_guide/#find-clusters-of-events-which-make-your-metric-rise-or-decrease","text":"Anomeda can calculate trends of the metric for each cluster in your data and show the most significat positive and negative contributions. It aggregates metric values by index, fit a line a * x + b, where x is index numeric value, and produce the output. anomeda.describe_trends_by_clusters(anmd_df) The output is a pandas.DataFrame with the following columns: - Measures - trend_coeff - Coefficient a of a fitted line a * x + b - trend_bias - Coefficient b of a fitted line a * x + b - avg_value - contribution_metric - Coefficient which describes how important the cluster for the total metric is. It is calculated as follows: sign(a) * abs(a * avg_value) , where a is coefficient a of a fitted line a * x + b","title":"Find clusters of events which make your metric rise or decrease"}]}